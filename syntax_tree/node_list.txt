
Node

Expression(Node)
Name(Expression)
Literal(Expression)

Definition(Node)
Pragma(Node)
Statement(Node)

Simple_Statement(Statement)
Compound_Statement(Statement)

Compilation_Unit(Node)
Script_File(Compilation_Unit)
Function_File(Compilation_Unit)
Class_File(Compilation_Unit)

Class_Definition(Definition)
Function_Definition(Definition)

Copyright_Info(Node)
Docstring(Node)
Function_Signature(Node)
Sequence_Of_Statements(Node)
Name_Value_Pair(Node)
Special_Block(Node)
Entity_Constraints(Node)
Argument_Validation_Delegation(Node)
Class_Enumeration(Node)
Action(Node)
Row(Node)
Row_List(Node)

Reference(Name)
Cell_Reference(Name)
Identifier(Name)
Selection(Name)
Dynamic_Selection(Name)
Superclass_Reference(Name)

For_Loop_Statement(Compound_Statement)
General_For_Statement(For_Loop_Statement)
Parallel_For_Statement(For_Loop_Statement)
While_Statement(Compound_Statement)
If_Statement(Compound_Statement)
Switch_Statement(Compound_Statement)
Try_Statement(Compound_Statement)
SPMD_Statement(Compound_Statement)

Simple_Assignment_Statement(Simple_Statement)
Compound_Assignment_Statement(Simple_Statement)
Naked_Expression_Statement(Simple_Statement)
Return_Statement(Simple_Statement)
Break_Statement(Simple_Statement)
Continue_Statement(Simple_Statement)
Global_Statement(Simple_Statement)
Persistent_Statement(Simple_Statement)
Import_Statement(Simple_Statement)

Tag_Pragma(Pragma)
No_Tracing_Pragma(Pragma)
Justification_Pragma(Pragma)
Metric_Justification_Pragma(Justification_Pragma)

Number_Literal(Literal)
Char_Array_Literal(Literal)
String_Literal(Literal)

Reshape(Expression)
Range_Expression(Expression)
Matrix_Expression(Expression)
Cell_Expression(Expression)
Function_Call(Expression)
Unary_Operation(Expression)
Binary_Operation(Expression)
Binary_Logical_Operation(Binary_Operation)
Lambda_Function(Expression)
Function_Pointer(Expression)
Metaclass(Expression)


class Statement(Node):

class Expression(Node):


class Simple_Statement(Statement):


class Simple_Assignment_Statement(Simple_Statement):

class Compound_Assignment_Statement(Simple_Statement):

class Naked_Expression_Statement(Simple_Statement):


class Return_Statement(Simple_Statement):

class Break_Statement(Simple_Statement):

class Continue_Statement(Simple_Statement):


class Global_Statement(Simple_Statement):

class Persistent_Statement(Simple_Statement):

class Import_Statement(Simple_Statement):


class Compound_Statement(Statement):

class Sequence_Of_Statements(Node):
  l_statements: List[Statement]


class For_Loop_Statement(Compound_Statement):
  t_for: Literal['for', 'parfor']
  n_ident: Identifier
  n_body: Sequence_Of_Statements

class General_For_Statement(For_Loop_Statement):
  n_expr: Expression

class Parallel_For_Statement(For_Loop_Statement):
  n_range: Range_Expression
  n_workers: Expression

class While_Statement(Compound_Statement):
  n_guard: Expression
  n_body: Sequence_Of_Statements

class Action(Node):
  n_expr: Expression
  n_body: Sequence_Of_Statements
  def kind(): str # if, elseif, else, case, otherwise

class If_Statement(Compound_Statement):
  l_actions: List[Action]

class Switch_Statement(Compound_Statement):
  n_expr: Expression # guard
  l_actions: List[Action]

class Try_Statement(Compound_Statement):
  n_body: Sequence_Of_Statements
  n_ident: Identifier # catch variable
  n_handler: Sequence_Of_Statements

class SPMD_Statement:
  n_ident: Sequence_Of_Statements